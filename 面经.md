<mark>**1.智能指针**</mark>

(**<mark>1</mark>**) ⾸先，说⼀下为什么要使⽤智能指针：智能指针其作⽤是管理⼀个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况的发⽣。
使⽤智能指针可以很⼤程度上的避免这个问题，因为智能指针就是⼀个类，当超出了类的作⽤域时，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是在函数结束时⾃动释放内存空间，不需要⼿动释放内存空间。

(**<mark>2</mark>**) 常用接口 

T* get();
T& operator*();
T* operator->();
T& operator=(const T& val);
T* release();
void reset (T* ptr = nullptr);

T 是模板参数, 也就是传⼊的类型；
get() ⽤来获取 auto_ptr 封装在内部的指针, 也就是获取原⽣指针；
operator() ᯿载 , operator->() ᯿载了->, operator=()᯿载了=；
realease() 将 auto_ptr 封装在内部的指针置为 nullptr, 但并不会破坏指针所指向的内容, 函
数返回的是内部指针置空之前的值；
直接释放封装的内部指针所指向的内存, 如果指定了 ptr 的值, 则将内部指针初始化为该值
(否则将其设置为nullptr）；

(**<mark>3</mark>**) 

(**<mark>a</mark>**) auto_ptr（C++98 的⽅案，C11 已抛弃）采⽤所有权模式。

auto_ptr p1 (new string ("hello"));
auto_ptr p2;
p2 = p1; //auto_ptr 不会报错.

此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运⾏时访问 p1 将会报错。所以 auto_ptr的缺点是：存在潜在的内存崩溃问题！
**(<mark>b</mark>)** unique_ptr（替换 auto_ptr ）
T* get();
T& operator();
T* operator->();
T& operator=(const T& val);
T* release();
void reset (T* ptr = nullptr);
auto_ptr p1 (new string ("hello"));
auto_ptr p2;
p2 = p1; //auto_ptr 不会报错.
unique_ptr 实现独占式拥有或严格拥有概念，保证同⼀时间内只有⼀个智能指针可以指向该对象。它对于避免资源泄露特别有⽤。
采⽤所有权模式，还是上⾯那个例⼦
编译器认为 p4=p3 ⾮法，避免了 p3 不再指向有效数据的问题。
因此，unique_ptr ⽐ auto_ptr 更安全。
(**<mark>c</mark>**) shared_ptr（共享型，强引⽤）
shared_ptr 实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后⼀个引⽤被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使⽤计数机制来表明资源被⼏个指针共享。
可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可
以通过传⼊auto_ptr, unique_ptr,weak_ptr 来构造。当我们调⽤ release() 时，当前指针会释放资源所有权，计数减⼀。当计数等于 0 时，资源会被释放。
shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性 (auto_ptr 是独占的)，在使⽤引⽤计数的机制上提供了可以共享所有权的智能指针。
(<mark>d</mark>) weak_ptr（弱引⽤）
weak_ptr 是⼀种不控制对象⽣命周期的智能指针，它指向⼀个 shared_ptr 管理的对象。进⾏该对象的内存管理的是那个强引⽤的 shared_ptr。
 weak_ptr 只是提供了对管理对象的⼀个访问⼿段。weak_ptr 设计的⽬的是为配合
shared_ptr ⽽引⼊的⼀种智能指针来协助 shared_ptr ⼯作，它只可以从⼀个 shared_ptr 或另⼀个 weak_ptr 对象构造,，它的构造和析构不会引起引⽤记数的增加或减少。

weak_ptr 是⽤来解决 shared_ptr 相互引⽤时的死锁问题，如果说两个 shared_ptr 相互引⽤，那么这两个指针的引⽤计数永远不可能下降为0，也就是资源永远不会释放。它是对对象的⼀种弱引⽤，不会增加对象的引⽤计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调⽤ lock 函数来获得shared_ptr。
当两个智能指针都是 shared_ptr 类型的时候，析构时两个资源引⽤计数会减⼀，但是两者引
⽤计数还是为 1，导致跳出函数时资源没有被释放（的析构函数没有被调⽤），解决办法：把其中⼀个改为weak_ptr就可以。

[weak_ptr基本用法以及怎么解决循环引用_星河九天的博客-CSDN博客](https://blog.csdn.net/m0_70418130/article/details/125980596)

<mark>**2.Final修饰符的作用**</mark>

（1）用来修饰类，让该类不能被继承

（2）用来修饰类的成员函数，以指示他们不能被派生类重写。使用final关键字可以帮助确保程序的安全性和正确性， 因为它能够防止程序员或其他人不小心或故意的修改或覆盖已经定义好的函数，从而破坏原始功能或引入错误。

<mark>**3.HTTP状态码**</mark>

505 ：服务器不支持请求的HTTP协议的版本，无法完成处理

504： 充当网关或代理的服务器，未及时从远端服务器获取请求

100： 继续。客户端应继续其请求

101： 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议

<mark>**4.MYSQL索引**</mark>

**<mark>5.MYSQL的buffer pool怎么清空</mark>**

使用如下命令：FLUSH BUFFER POOL；

这个命令将会清空所有的缓存页， 使得MYSQL需要重新读取磁盘上的数据，当然，这也意味着下一次查询可能会比较慢，因为需要重新从磁盘中读取数据到内存中。

**<mark>6.虚函数，虚表</mark>**

（1）⼦类是否要重写⽗类的虚函数？⼦类继承⽗类时， ⽗类的纯虚函数必须重写，否则⼦
类也是⼀个虚类不可实例化。 定义纯虚函数是为了实现⼀个接⼝，起到⼀个规范的作⽤，规
范继承这个类的程序员必须实现这个函数。

（2）https://blog.csdn.net/weixin_45138932/article/details/125667041

（3）/home/gu/c++/C%20八股文/C++八股文/暗黑风格-C++八股文-小贺-v1.0.pdf   <mark>22</mark>

（4）构造函数为什么不能声明为虚函数？

a）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等

b）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了

（5）构造函数或析构函数中调⽤虚函数会怎样？

一般情况下，不允许在构造函数或者[析构函数](https://so.csdn.net/so/search?q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)中调用虚函数。其实语法上都没有问题，只是会失去多态性。

如果在构造函数中调用[虚函数](https://so.csdn.net/so/search?q=%E8%99%9A%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)，会先调用父类中的实现，也就失去了多态的性质。

出现上述结果的原因是因为，构造函数还没有将vptr和vtable初始化完毕，就调用虚函数，此时必然调用的基类中的实现。

而在析构函数中，因为子类的那部分已经被析构掉了，此时在父类的析构函数调用虚函数，调用的也只能是父类中的实现。

**<mark>7.c++编译过程</mark>**

/home/gu/c++/C%20八股文/C++八股文/暗黑风格-C++八股文-小贺-v1.0.pdf  <mark>40</mark>

之所以要经过预处理、编译、汇编这么一系列步骤才生成目标文件，是因为在每一阶段都有相应的优化技术，只有在每个阶段分别优化并生成最为高效的机器指令才能达到最大的优化效果，如果一步到位直接从源程序生成目标文件，可能就会失去很多代码优化的机会。

（4）链接（Linking）
由链接器完成，主要解决多个文件之间符号引用的问题，即symbol resolution。编译时编译器只对单个文件进行处理，如果该文件里面需要引用到其他文件中的符号，比如全局变量或者调用了某个库函数中的函数，那么这时候，在这个文件中该符号的地址是没法确定的，只能由链接器把所有的目标文件链接到一起才能确定最终的地址，并生成最终的可执行文件。无论采用静态链接还是动态链接，都会生成一个可以在计算机上执行的可执行程序。
**<mark>8.是否了解STL ？ map和unordered_map区别</mark>**

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的， std::unordered_map的key无序

查询效率和增删效率：std::map 和std::multimap都为O(logn), std::unordered_map为O(1).

**<mark>9.inline函数？</mark>**

（1）inline 函数由 inline 关键字定义，引入 inline 函数的主要原因是用它替代 C 中复杂易错不易维护的宏函数。

（2）编译器在编译阶段完成对 inline 函数的处理，即对 inline 函数的调用替换为函数的本体。但 inline 关键字对编译器<mark>只是一种建议</mark>，编译器可以这样去做，也可以不去做。从逻辑上来说，编译器对 inline 函数的处理步骤一般如下：
（a）将 inline 函数体复制到inline函数调用处；
（b）为所用 inline 函数中的局部变量分配内存空间；
（c）将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
（d）如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用GOTO）。
（3）inline函数优缺点：

**优点：**

（a）内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。

（b）内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。

（c）在类中声明同时定义的[成员函数](https://so.csdn.net/so/search?q=%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。

（d）内联函数在运行时可调试，而宏定义不可以。

**缺点：**

（a）代码膨胀。
inline函数带来的运行效率是典型的以空间换时间的做法。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

（b）inline 函数无法随着函数库升级而升级。
如果f是函数库中的一个inline函数，使用它的用户会将f函数实体编译到他们的程序中。一旦函数库实现者改变f，所有用到f的程序都必须重新编译。如果f是non-inline的，用户程序只需重新连接即可。如果函数库采用的是动态连接，那这一升级的f函数可以不知不觉的被程序使用。

（c）是否内联，程序员不可控。
inline函数只是对编译器的建议，是否对函数内联，决定权在于编译器。编译器认为调用某函数的开销相对该函数本身的开销而言微不足道或者不足以为之承担代码膨胀的后果则没必要内联该函数，若函数出现递归，有些编译器则不支持将其内联。

（4）inline与define的区别: #define是关键字，inline是函数；
宏定义在预处理阶段进⾏⽂本替换，inline 函数在编译阶段进⾏替换；
inline 函数有类型检查，相⽐宏定义⽐较安全；

（5）使用注意：[C++ inline 函数简介_恋喵大鲤鱼的博客-CSDN博客](https://blog.csdn.net/K346K346/article/details/52065524)

（a）使用函数指针调用内联函数将会导致内联失败。
也就是说，如果使用函数指针来调用内联函数，那么就需要获取inline函数的地址。如果要取得一个inline函数的地址，编译器就必须为此函数产生一个函数实体，那么就内联失败。

（b）如果函数体代码过长或者有多重循环语句，if或witch分支语句或递归时，不宜用内联。

（c）类的 constructors、destructors 和虚函数往往不是 inline 函数的最佳选择。
类的构造函数（constructors）可能需要调用父类的构造函数，析构函数同样可能需要调用父类的析构函数，二者背后隐藏着大量的代码，不适合作为inline函数。虚函数往往是运行时确定的，而inline是在编译时进行的，所以内联虚函数往往无效。如果直接用类的对象来使用虚函数，那么对有的编译器而言，也可起到优化作用。

（d）至于内联函数是定义在头文件还是源文件的建议。
内联展开是在编译时进行的，只有链接的时候源文件之间才有关系。所以内联要想跨源文件必须把实现写在头文件里。如果一个 inline 函数会在多个源文件中被用到，那么必须把它定义在头文件中。

**<mark>10.webserver项目作用</mark>**

这是一个基于Linux平台下的轻量级的web服务器项目，可实现上万的并发连接，项目中主要用的技术有，线程池 + 非阻塞socket+epoll+事件处理的并发模型，状态基解析http请求，以及支持同步和异步的日志系统

线程池是服务器预先创建的一组子线程，子线程拥有相同的代码和属性，当有新的任务到来时，主线程会通过某种算法来选择子线程为之服务。

相比于动态创建子线程，选择已经存在的子线程为之服务，开销要小的多

动态创建的子线程一般只能为一个客户服务，这将导致很多的细微线程产生，线程的切换会花费大量时间

//socket通信设置为非阻塞，边沿触发避免由于一个文件描述符的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死

epoll高效的IO复用技术

两种高效的事件处理模型 Reactor（实现简单）和Proactor（性能更高）

同步 I/O 模型通常用于实现 Reactor 模式，异步 I/O 模型通常用于实现 Proactor 模式。

主要区别就是 真正的读取和写入操作是由谁来完成的。

Reactor来了事件操作系统通知应用进程，让应用进程来处理；
Proactor来了事件操作系统来处理，处理完再通知应用进程。

有限状态机：根据应用层协议的不同类型字段，映射为逻辑单元的不同执行状态，服务器可以根据此来编写相应的处理逻辑

**<mark>11.reactor高并发是什么</mark>**

[9.3 高性能网络模式：Reactor 和 Proactor | 小林coding](https://www.xiaolincoding.com/os/8_network_system/reactor.html#%E6%BC%94%E8%BF%9B)

即I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。

**<mark>12.什么是I/O多路复用？</mark>**

[9.2 I/O 多路复用：select/poll/epoll | 小林coding](https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84-socket-%E6%A8%A1%E5%9E%8B)

基于进程或者线程的模型，新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。

既然为每个请求分配一个进程/线程的方式不合适，只使用一个进程来维护多个 Socket 的方式，就是 **I/O 多路复用**技术。

一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。

我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，**进程可以通过一个系统调用函数从内核中获取多个事件**。

select/poll/epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。

**<mark>13.你用了什么IO多路复用技术</mark>**

epoll

[9.2 I/O 多路复用：select/poll/epoll | 小林coding](https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#select-poll)

select：使用固定长度的BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 `1024`，只能监听 0~1023 的文件描述符。

poll：不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。

 poll 和 select 并没有太大的本质区别，**都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合**，这种方式随着并发数上来，性能的损耗会呈指数级增长。

epoll: 先复习下 epoll 的用法。先用epoll_create 创建一个 epoll对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据。

epoll 通过两个方面，很好解决了 select/poll 的问题。

*第一点*，epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字**，把需要监控的 socket 通过 `epoll_ctl()` 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 `O(logn)`。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。

*第二点*， epoll 使用**事件驱动**的机制，内核里**维护了一个链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中，当用户调用 `epoll_wait()` 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。

插个题外话，网上文章不少说，`epoll_wait` 返回时，对于就绪的事件，epoll 使用的是共享内存的方式，即用户态和内核态都指向了就绪链表，所以就避免了内存拷贝消耗。

这是错的！看过 epoll 内核源码的都知道，**压根就没有使用共享内存这个玩意**。你可以从下面这份代码看到， epoll_wait 实现的内核代码中调用了 `__put_user` 函数，这个函数就是将数据从内核拷贝到用户空间。

epoll 支持两种事件触发模式，分别是边缘触发（*edge-triggered，ET*）和水平触发（*level-triggered，LT*）。

- 使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，**服务器端只会从 epoll_wait 中苏醒一次**，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；
- 使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，**服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束**，目的是告诉我们有数据需要读取；

一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。

select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。

另外，使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用

简单点理解，就是**多路复用 API 返回的事件并不一定可读写的**，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞，因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况。

**<mark>14.Void*的作用</mark>**

指针是一个地址，有两个属性，一个是起始地址，一个是长度，起始地址告诉编译器从哪里开始寻址，地址长度由编译器根据指针所指对象的类型进行推断，如int占4字节，double占8字节。int*从指定地址向后寻找4字节作为变量的存储单元 。double*从指定地址向后寻找8字节作为变量的[存储单元](https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83&spm=1001.2101.3001.7020)  
这里补充一点：不同类型的指针+1跳过的字节数是不同的。

(a)**void指针是一种特别的指针**

void *vp

//说它特别是因为它没有类型 

//或者说这个类型不能判断出指向对象的长度

(b) **任何指针都可以赋值给void指针**

   type *p; 
   vp=p; 

   //不需转换 
   //只获得变量/对象地址而不获得大小 

(c) **void指针赋值给其他类型的指针时都要进行转换**

   type * *p = (type* *)vp; 
   //转换类型也就是获得指向变量/对象大小 

(d)# **void指针不能解引用**

   *vp//错误 
   因为void指针只知道,指向变量/对象的起始地址 
   而不知道指向变量/对象的大小(占几个字节)所以无法正确引用 

(e)# **void*的作用**

void* 定义一个指针变量，但不说明他指向哪一种类型

1.传参：通用类型

可以作为函数模板，链表等参数的通用参数。在使用时，只需要强制类型转换就可以。

2.强制类型转换

有时候由于重载等的干扰，导致需要转换成void *，来进行取地址。  
例如，(void *)obj.member，就可以取到member的地址；直接&(obj.member)取到的实际上是obj的开始地址。

3.指向0的地址

(void *)0，指向全是0的地址，相当于NULL。

**<mark>15.函数中声明的不是malloc的数组怎么返回</mark>**

 声明一个静态本地数组，并返回一个指针。 这“有效”，因为静态数组在超出范围时不会被释放。但它不安全，因为下次使用该函数时将覆盖该数组(在多线程场景中尤其糟糕)。

在调用函数时传入数组地址：  
在主函数中定义了一个数组，然后在调用自定义函数时，将该数组的地址当作参数传递过去，这样也可以成功的使用数组中的内容，并在自定义函数生命周期结束后将内容返回。

**<mark>16.常见的内存泄漏的情况，我说了基本的几种之后，他说如果这些程序员导致的错误不犯，还有哪些，我以为他想问虚析构函数，但是我get错他的点了</mark>**

### **1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数**

> 两种情况下会出现这种内存泄露：
> 
> （1）在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；
> 
> （2）在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存；

### **2. 没有正确地清除嵌套的对象指针**

### **3. 在释放对象数组时在delete中没有使用方括号**

> 方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值病调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露；
> 
> 释放单个对象、单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数；

### **4. 指向对象的指针数组不等同于对象数组**

> 对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间；
> 
> 指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了；

### **5. 缺少拷贝构造函数**

> 两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。
> 
> 按值传递会调用（拷贝）构造函数，引用传递不会调用。
> 
> 在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。
> 
> 所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符

### **6. 缺少重载赋值运算符**

> 这种问题跟上述问题类似，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露；

### **7. 没有将基类的析构函数定义为虚函数**

> 当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

除编程错误外，还有其他情况可能导致内存泄漏：

**操作系统限制**：在某些情况下，即使程序请求，操作系统也可能无法发布内存资源。由于操作系统或硬件的限制，或者由于错误或错误配置，可能会发生这种情况。

**外部因素**：程序使用的某些软件库或插件也可能具有内存泄漏，即使程序本身不含错误。在这种情况下，内存泄漏可能不是程序本身的错，而是其所依赖的外部组件。

**效率低下的算法**：使用效率低的算法的程序可能会消耗超过必要的内存，从而导致内存泄漏随着时间的流逝。例如，即使不积极使用的程序，也可能会遭受内存泄漏的影响，该程序即使不积极使用，也将大量数据存储在内存中。

**高负载和压力测试**：受到高负载和压力测试的程序，即使它们没有漏洞，也可能会出现内存泄漏。由于对系统的需求增加，这可能会发生这种情况，从而导致内存分配和交易问题。

总之，虽然编程错误是记忆泄漏的最常见原因，但还有其他情况也可能导致它们。对于开发人员而言，重要的是要意识到这些潜在原因，并采取步骤防止记忆泄漏在其程序中发生。

内存泄漏分为以下两类：

- 堆内存泄漏：我们经常说的内存泄漏就是堆内存泄漏，在堆上申请了资源，在结束使用的时候，没有释放归还给OS，从而导致该块内存永远不会被再次使用

- 资源泄漏：通常指的是系统资源，比如socket，文件描述符等，因为这些在系统中都是有限制的，如果创建了而不归还，久而久之，就会耗尽资源，导致其他程序不可用

**<mark>17.匿名函数和函数指针的区别，我就说了下匿名函数的捕获。</mark>**

Lambda 表达式：Lambda 表达式是在 C++11 中引入的。引入它的原因是为了消除使用函数指针时所面临的复杂性或麻烦性。要使用函数指针，需要创建一个单独的函数。之后，创建指向该函数的函数指针，然后将其作为参数传递给所需的函数。

由于使用函数指针执行的任务很小，因此不值得写那么多行代码。因此，Lambda 表达式可以更轻松地完成相同的工作。

Lambda 表达式也称为匿名函数。它是包含在主函数中的表达式，有助于将行为作为参数传递给函数。在默认情况下，它无权访问主函数中存在的任何变量。要访问这些，需要对表达式的捕获列表进行一些修改

匿名函数是没有名称定义的函数，通常在运行时创建。它也称为 lambda 函数或闭包。匿名函数通常用作高阶函数的参数或用于定义小型的一次性函数。

相反，函数指针是一个保存函数内存地址的变量。它是对内存中函数的引用，允许通过指针间接调用它。函数指针通常用于低级编程，例如用于在事件驱动编程中实现回调函数。

匿名函数和函数指针之间的主要区别在于，匿名函数是动态创建的，不与特定的内存位置相关联，而函数指针被显式定义为保存特定函数在内存中的地址的变量。此外，匿名函数通常用于高阶函数，而函数指针更常用于低级编程和回调。

**<mark>18.写代码中，你经常使用的容器有哪些？</mark>**

**<mark>19.vector,list,map,unordered_map各自的特点及原理</mark>**

home/gu/c++/C%20八股文/C++八股文/暗黑风格-C++八股文-小贺-v1.0.pdf

**vector和list区别**
从底层实现来说，vector是通过数组实现的，存储空间上是一段连续的存储空间；list是通过双向链表实现的，把不连续的内存块通过链表的方式连接在一起。
从插入删除时间复杂度来说，vector是随机访问的O(1)，但是插入和删除需要移动元素O(n)。 list不支持随机访问，需要遍历链表来查询O(n), 但是插入和删除效率就很高。
vector空间扩大，增大的方式是首先找到一个两倍大的内存空间，然后将原有的元素通过复制的方式初始化新的空间，然后析构释放原空间，这样会有个问题就是原有的迭代器都是指向原空间的，现在就失效了。

**map的实现原理**
map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。内部的实现采用了红黑树，红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树存储的，使用中序遍历可将键值按照从小到大遍历出来。

**unorder_map实现原理**
unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。

**map：**
优点 有序性，红黑树使得很多操作在logn的时间复杂度下就可以实现。
缺点 空间占用率高，虽然提高了效率但是每个节点都要保存父节点 孩子节点以及红黑的性质信息。

**unorder_map：**
优点：查找速度比map更快
缺点：建立hashmap比较花时间，内存会比map高一些

vector：

vector是一个可以增大或缩小大小的动态数组。

vector中的元素存储在连续的内存位置，使用指针访问它们很容易。

Vector 支持随机访问，这意味着您可以在常数时间内访问 vector 中的任何元素。

从 vector 末尾添加或删除元素是高效的，但从 vector 中间插入或删除元素相对昂贵。

当您需要存储大量需要随机访问的元素时，Vector 很有用。

list：

list是一个双向链表，可以增加或缩小大小。

与向量不同，列表中的元素不存储在连续的内存位置，因此您不能使用指针访问它们。

List 支持双向迭代器，这意味着您可以双向遍历列表。

从list中间添加或删除元素是高效的，但随机访问元素相对昂贵。

当您需要频繁地从列表中间插入或删除元素时，List 很有用。

map：

映射是一个关联容器，它将元素存储为键值对。

map中的元素按其键排序，每个键在map中只能出现一次。

Map 使用二叉搜索树来存储元素，这使得它可以高效地搜索和插入元素。

当您需要存储大量需要通过键访问的键值对时，Map 很有用。

unordered_map：

unordered_map 是一个关联容器，将元素存储为键值对。

与map不同，unordered_map 中的元素不按其键排序。

Unordered_map 使用哈希表来存储元素，这使得它可以高效地搜索和插入元素。

Unordered_map 在需要存储大量的键值对，需要通过它们的键访问，但又不关心元素的顺序时很有用

**<mark>20.vector怎么实现扩容的  </mark>**

**<mark>21.怎么降低扩容次数(reserve,resize)  </mark>**

[vector在使用过程中会动态扩容，势必会造成不少延时，如何减少这种情况发生？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/614741647)

**<mark>22.reserve,resize它俩的区别  </mark>**
resize()：改变当前容器内含有元素的数ᰁ(size())，eg:  vector v;  v.resize(len);

v的size变为len, 如果原来v的size⼩于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；如果大于len，则截断。

reserve()：改变当前容器的最⼤容量（capacity）,它不会⽣成元素，只是确定这个容器允许放⼊多少对象，如果reserve(len)的值⼤于当前的capacity()，那么会重新分配⼀块能存len个对象的空间，然后把之前v.size()个对象通过 copy construtor 复制过来，销毁之前的内存；

**<mark>23.map为什么使用红黑树，与AVL有什么区别，为什么不用AVL实现？  </mark>**

MAP使用红黑树来进行其基础数据结构，因为它在效率和简单性之间提供了良好的平衡.

红⿊树是⼀种⼆叉查找树，但在每个节点上增加⼀个存储为⽤于表示节点的颜⾊，可以是红或者⿊。通过对任何⼀条从根到叶⼦节点的路径上各个节点的着⾊⽅式的限制，**红⿊树确保没有⼀条路径会⽐其他路径⻓出两倍**，因此，红⿊树是⼀种弱平衡树，**但⼜相对与要求严格的AVL树来说，他的旋转次数较少**，所以对于**搜索，插⼊，删除**操作⽐较多的情况下，通常使⽤红⿊树。

红色树木和AVL树都是自动平衡的二进制搜索树，这意味着它们会自动调整其结构以保持平衡树，从而确保可以在O(log N)时间复杂性中完成诸如插入，删除和搜索之类的树木操作。

但是，AVL树比红色树木更加平衡，这意味着它们需要更频繁的旋转才能保持平衡。

实施复杂性：

红色树木比AVL树更容易实施，因为它们需要更少的旋转，并且更容易容忍轻微的失衡。

AVL树需要更复杂的平衡算法来维持其平衡，这可能会使它们实施更具挑战性，并且在某些情况下也可以导致性能较慢

1. AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。
2. 红黑树更适合于插入修改密集型任务。
3. 通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。

**<mark>24.TCP的三次握手与四次挥手  </mark>**

[4.1 TCP 三次握手与四次挥手面试题 | 小林coding](https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html)

**<mark>25.智力题:羊，车奖品问题  </mark>**
**三个门，两个门后面是羊，一个门后面是车，现在你选择一个门，主持人会给你打开一个不是车的门，你有一次换门的机会，请问，是否要换？(是否会提升你的中奖概率)**

这题的答案是选择另外一个门比坚持1号门获得汽车的概率会增加一倍。

只有第一次选对了，不换才能中奖。 第一次选错，换才能中奖。第一次选对的概率是1/3所以换比不换合适。

**<mark>26.c++的static和const的区别，讲讲具体的用法，举个例子</mark>**

[(147条消息) const与static的区别_static和const的区别_Polymer to C++的博客-CSDN博客](https://blog.csdn.net/m0_56374992/article/details/117919773)

/home/gu/c++/C%20八股文/C++八股文/暗黑风格-C++八股文-小贺-v1.0.pdf

[基础语法-21-40 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-02-basic.html)

cpp和c中的const全局变量都是放在常量区的，因此一定是不可以修改的

- 但是C语言中const全局变量默认是外部链接的，即可以跨文件使用，在一个文件里`const int a = 10`，在另一个文件中可以直接`extern const int a`声明一下即可使用。
- CPP则默认是内部链接，即作用域限定在本文件内，如果非要跨文件使用则在定义的时候就要用`extern`声明一下来提升作用域。即定义的时候就是`extern const int a = 10`，使用的时候还要声明`extern const int a`

**<mark>27.进程线程区别，进程如何切换的</mark>**

[5.1 进程、线程基础知识 | 小林coding](https://www.xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B)

[操作系统01-20 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-os.html)

E:/工作/my/c++%20书/C%20八股文/C++八股文/暗黑风格-C++八股文-小贺-v1.0.pdf

**<mark>28.linux中为什么设计了内核态和用户态，有什么方式进行内核态和用户态的切换</mark>**

**为什么**：

保护机制。**防止用户进程误操作或者是恶意破坏系统。**内核态类似于C++的私有成员，只能在类内访问，用户态类似于公有成员，可以随意访问。

在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。所以，CPU 将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。

**用户态切换到内核态的方式：**

1、系统调用（主动）

由于用户态无法完成某些任务，用户态会请求切换到内核态，内核态通过为用户专门开放的中断完成切换。

2、异常（被动）

在执行用户程序时出现某些不可知的异常，会从用户程序切换到内核中处理该异常的程序，也就是切换到了内核态。

3、外围设备中断（被动）

外围设备发出中断信号，当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进程处理，如果中断之前CPU执行的是用户态程序，就相当于从用户态向内核态的切换。

<mark>**29.口述算法：4亿数据找几个数，说了两种方法，分段载入内存再遍历，用外排序进行归并排序再二分搜索**</mark>

[海量数据处理01-05 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/07-01-massive_data.html)

**<mark>30.设计一个strcpy函数？（答了dest长度不够怎么办，拷贝用memcpy，释放空指针，结尾补`\0`）</mark>**

[strcpy函数详解看这一篇就够了-C语言（函数实现、使用用法举例、与strncpy的区别）_lambo mercy的博客-CSDN博客](https://blog.csdn.net/m0_65601072/article/details/123967796)

**<mark>31.你设计的这个函数中有什么bug吗？（只回答了结尾`\0`和NULL的问题）</mark>**

**<mark>32.strlen和sizeof的区别</mark>**

[基础语法-01-20 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_16%E3%80%81strlen%E5%92%8Csizeof%E5%8C%BA%E5%88%AB)

**<mark>33.内存管理中堆和栈的区别</mark>**

[基础语法-01-20 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_5%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB)

**<mark>34.栈与队列的区别</mark>**

1、队列先进先出，栈先进后出。

2、对插入和删除操作的"限定"不同。

栈是限定只能在表的一端进行插入和删除操作的线性表。     

队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。  

3、遍历数据速度不同。

栈只能从头部取数据，也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性。

队列则不同，它基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的多

**<mark>35.static是全局变量吗</mark>**

不一定

**<mark>36.malloc和new的区别</mark>**

[基础语法-01-20 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_8%E3%80%81new-delete-%E4%B8%8E-malloc-free%E7%9A%84%E5%BC%82%E5%90%8C)[基础语法-01-20 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_8%E3%80%81new-delete-%E4%B8%8E-malloc-free%E7%9A%84%E5%BC%82%E5%90%8C)

**<mark>37.封装、继承、多态</mark>**

/home/gu/c++/C%20八股文/C++八股文/暗黑风格-C++八股文-小贺-v1.0.pdf

第21条

**<mark>38.c++11为什么弃用auto_ptr (忘了)</mark>**

（1）auto_ptr在拷贝和赋值操作时会导致所有权转移，因此只要auto_ptr以实参传递，就会引发致命的运行期错误。

（2）使用容器保存auto_ptr后，在进行操作后，可能导致容器中保存的原auto_ptr所管理的对象已经失效，如使用排序算法。

auto_ptr采用**copy语义来转移指针资源**，**转移指针资源的所有权的同时将原指针置为NULL，这跟通常理解的copy行为是不一致的(不会修改原数据)，而这样的行为在有些场合下不是我们希望看到的**。

sort的快排实现中有将元素复制到某个**局部临时对象**中，但对于auto_ptr，却将原元素置为null，这就导致最后的排序结果中可能有大量的null。

**<mark>38.你项目中用哪一种指针比较多？</mark>**

shared_ptr是引用计数的智能指针，被奉为裸指针的完美替身，因此被广泛使用

**<mark>39.socket如何建立的？</mark>**

[5.2 进程间有哪些通信方式？ | 小林coding](https://www.xiaolincoding.com/os/4_process/process_commu.html#socket)

**<mark>40.TCP/IP模型</mark>**

[2.1 TCP/IP 网络模型有哪几层？ | 小林coding](https://www.xiaolincoding.com/network/1_base/tcp_ip_model.html)

41.linux的命令们：chmod，scp，chattr，pgrep，awk

chmod命令 – 改变文件或目录权限

scp命令 – 远程拷贝文件

chattr命令 – 更改文件属性

pgrep命令 – 用于检索当前正在运行的进程
awk命令 – 文本和数据进行处理的编程语言

**<mark>42.讲一下你项目里的脚本怎么设计的（主要是shell编程）</mark>**

&&&

**<mark>43.如何后台运行程序？（答了&和nohup）</mark>**

[操作系统21-40 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-02-os.html#_31%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C)

[Linux下将ctrl+z挂起的进程恢复到后台启动_ctrl z 后台_L-960的博客-CSDN博客](https://blog.csdn.net/weixin_43702146/article/details/126389028)

**<mark>44.那么&和nohup有什么区别？（忘了）</mark>**

在命令的末尾加个&符号后，程序可以在后台运行，但是一旦当前终端关闭（即退出当前帐户），该程序就会停止运行。那假如说我们想要退出当前终端，但又想让程序在后台运行，该如何处理呢？

实际上，这种需求在现实中很常见，比如想远程到服务器编译程序，但网络不稳定，一旦掉线就编译就中止，就需要重新开始编译，很浪费时间。

在这种情况下，我们就可以使用nohup命令。nohup就是不挂起的意思( no hang up)。该命令的一般形式为：

```text
nohup ./test &
```

如果仅仅如此使用nohup命令的话，程序的输出会默认重定向到一个nohup.out文件下。如果我们想要输出到指定文件，可另外指定输出文件：

```text
nohup ./test > myout.txt 2>&1 &
```

这样一来，多管齐下，既使用了nohup命令，也使用了&符号，同时把标准输出/错误重定向到指定目录下。

使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。

**<mark>45.讲讲epoll</mark>**

[9.2 I/O 多路复用：select/poll/epoll | 小林coding](https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#epoll)

**<mark>46.List和vector遍历哪个快</mark>**

vector为随机访问容器，可直接通过下标访问数据，数据在内存连续排列，cache miss机率小。而list容器一般有头尾指针，遍历时需要跳转，内存分布不连接, cache miss机率大。但为什么debug模式下list比vector快，暂时不能解释

**<mark>47.指针和引用的区别</mark>**

[基础语法-01-20 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_3%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB)

**<mark>48.说一下缺页中断</mark>**

#### 得分点

缺页、分类、中断、缺页中断发生时的事件顺序

#### 参考答案

**标准回答**

1. 概念
   
   缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。当软件试图访问已映射在虚拟地址空间中，但是并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。而如果访问是不被允许的，那么操作系统通常会结束相关的进程。

2. 分类
   
   - 软性页缺失：指页缺失发生时，相关的页已经被加载进内存，但是没有向 MMU 注册的情况。操作系统只需要在 MMU 中注册相关页对应的物理地址即可。
   - 硬性页缺失：硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。
   - 无效页缺失：当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。

3. 中断
   
   中断是指计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回现行程序的间断处，继续执行原程序。

**加分回答**

缺页中断发生时的事件顺序：

- 硬件陷入内核，在堆栈中保存程序计数器，将当前指令的各种状态信息保存在特殊的 CPU 寄存器中；

- 保存通用寄存器和其他易失的信息，以免被操作系统破坏；

- 当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么；

- 一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰；

- 如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用；

- 一旦页框“干净”后，操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行；

- 当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态；

- 恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令；

- 调度引发缺页中断的进程，操作系统返回调用它的汇编语言程序；

- 该程序恢复寄存器和其他状态信息，返回到用户空间继续执行。
  
  1、 首先说明什么是缺页。内存管理时我们采用的是虚拟内存，虚拟内存并不能与实际内存建立完全的映射关系。缺页就是虚拟内存无法与实际内存建立映射的一种情况。我们通过页表的状态位判断是否产生缺页。缺页发生时，我们就需要将虚拟内存对应的外存中的那一页调入内存。而整个的实现过程是通过中断进行的。
  
  2、 这里的缺页中断的流程与普通中断没有区别。就是当系统发现缺页，从而产生中断。需要保存当前的状态，然后进入缺页中断处理程序，之后再恢复原来的状态，继续运行程序。
  
  3、 具体的缺页中断处理也要分为两类：第一类是此时内存中还有空闲块，我们直接将缺页从外存中调入内存；第二类是内存已满，需要采用页面置换算法淘汰某页再进行调入。

**<mark>49.TCP在哪一层</mark>**

传输层

**<mark>50.HTTP基于什么</mark>**

http协议是基于TCP/IP协议之上的应用层协议。

基于 请求-响应 的模式

**<mark>51.输入域名到页面渲染经历了什么</mark>**

[从浏览器输入地址到页面渲染都经历了哪些过程_浏览器输入地址到渲染经过哪些过程_沐日（Shrek）的博客-CSDN博客](https://blog.csdn.net/qq_53499304/article/details/124394561)

**<mark>52.讲讲B+树</mark>**

[为什么 MySQL 采用 B+ 树作为索引？ | 小林coding](https://www.xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html)

主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。

**<mark>53.红黑树原理</mark>**

[目前最详细的红黑树原理分析（大量图片+过程推导！！！） - 西*风 - 博客园](https://www.cnblogs.com/yinbiao/p/10732600.html)

**<mark>54.你还了解哪些logN复杂度查询的数据结构</mark>**

**(1) 二叉搜索树**

二叉搜索树时间复杂度分析：  
它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。

二叉搜索树空间复杂度分析：  
每个节点只需要存放当前节点的key值，所以空间复杂度为O(n)。

**(2)二叉平衡树**

在AVL树中插入元素同在一般BST完全一样的进行，但是每一次都会判断平衡因子是否被破坏，从而判断是否需要进行旋转操作。而每次 AVL 旋转都耗费恒定的时间，插入处理在整体上耗费 O(log n) 时间。
在AVL树中查找同在一般BST完全一样的进行，所以耗费 O(log n) 时间，因为AVL树总是保持平衡的。不需要特殊的准备，树的结构不会由于查询而改变。
查找、插入和删除在平均和最坏情况下都是O(log n)。

二叉平衡树空间复杂度分析：
每个节点只需要存放当前节点的key值，所以空间复杂度为O(n)，但相比二叉排序树需要更多空间。

**(3)二叉伸展树**

在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。
它的优势在于不需要记录用于平衡树的冗余信息。
二叉伸展树时间复杂度分析：
伸展树是一种二叉排序树，它能在O(log n)内完成插入、查找和删除操作。伸展树支持所有的二叉树操作。伸展树不保证最坏情况下的时间复杂度为O(logN)。伸展树的时间复杂度边界是均摊的。

二叉平衡树空间复杂度分析：
由于Splay Tree仅仅是不断调整，并没有引入额外的标记，无需记录额外的什么值来维护树的信息，从空间角度来看，要高效得多。所以空间复杂度为O(n)。
**(4)跳表**

[跳表（Skip List）_wink22的博客-CSDN博客](https://blog.csdn.net/weixin_45480785/article/details/116293416)

跳表查找时间复杂度分析：
1.查找包括两个循环，外层循环是从上层至底层，内层循环是在同一个level，从左到右。
2.跳表的高度极大概率为O(logn)，所以外层循环的次数以极大概率为O(logn)
3.在上层查找比对过的key，不会再下层再次查找对比，任意一个key被查找的比对的概率是1/2，因此内层循环的比对次数期望约等于2，即O(1)。
4.最终查找时间= O(1) * O(logn) = O(logn)

跳表空间复杂度分析：
每层元素个数期望值为1/2^k。列表空间大小为O(2n)。跳表是多级索引链表结构，是一种典型的“以空间换取时间”的做法。
**(5)数组**

时间复杂度：  
顺序查找O(n)，二分查找O(logn)

空间复杂度  
O(n)

**<mark>55.讲讲4种隔离级别</mark>**

[MySQL01-20 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html#_10%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)

[事务隔离级别是怎么实现的？ | 小林coding](https://www.xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B)

**<mark>56.讲一下协程</mark>**

[操作系统01-20 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-os.html#_1%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB)

**<mark>57.条件变量怎么用，说一个使用情况</mark>**

条件变量（cond）和锁（mutex）是紧密相关的，锁的使用场景是：这件事同时只有一个人能做，我抢到锁就进去做了，我做完再给下一个人做。这时就加个锁，保证某些变量同时只被一个线程操作。
什么情况下要用到条件变量呢，首先这件事还是只能一个人做，所以还要用锁。但线程抢到锁了后，发现还要等待一些条件满足，才能做。
这时怎么办呢？难道抢到锁的线程要不停检查这个条件吗？消耗高不说，每次检查完总得sleep一下吧，不然cpu都空跑了，sleep的时间怎么定？sleep少了，消耗高；多了，又有延迟，不能即时发现条件满足了。而且你抢到锁一直检查，别人也拿不到锁了。
这时就引入了条件变量，抢到锁的线程发现条件未满足时，释放锁，使用pthread_cond_wait()挂起自己；这时别的线程也能获取锁进来，发现条件不满足同样挂起；直到条件满足后，由其他方调用pthread_cond_broacast（唤醒全部挂起的线程）或者pthread_cond_signal（唤醒一个线程），通知这些挂起的线程说：条件好了，快来做吧，这时，第一个抢到锁的线程进去就可以干活了。

为什么提到cond经常会提到消费者生产者模型呢？
因为生产者消费者模型正好满足这种情况：1. 同一时间事情只能一人来做：生产者消费者都要操作同一个队列（或者其他容器），容器需要桶保护 2. 要满足条件才能干事：需要调生产出东西来，才能消费。所以消费方是pthread_cond_wait等待的那一方，生产者是pthread_cond_signal通知的那一方。
[简单讲讲条件变量pthread_cond究竟是干什么的和适用场景_条件变量的使用场景_淡然的心扉的博客-CSDN博客](https://blog.csdn.net/weixin_42919176/article/details/100119877)

**<mark>58.C++构造函数能不能是虚函数，有什么作用</mark>**

[其余问题-01-20 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_3%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%91%A2)

**<mark>59.动态链接库</mark>**

[基础语法-121-140 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-07-basic.html#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5)

/home/gu/c++/C%20八股文/C++八股文/暗黑风格-C++八股文-小贺-v1.0.pdf

**<mark>61.malloc之后怎么在里面创建一个指针变量</mark>**

```
// 分配一块内存
int *ptr = (int*)malloc(sizeof(int));

// 在分配的内存中创建指针变量
int **pptr = (int**)malloc(n * sizeof(int*));//此处n == 1
*pptr = ptr;

cout << *ptr << endl; //ptr 指向的地址的值
cout << &ptr << endl;//ptr 本身的地址
cout << ptr << endl;//ptr 指向的地址
```

其中，第一行代码分配了一块大小为int类型的内存，并将返回的指针赋值给ptr变量。第二行代码分配了一块大小为int指针类型的内存，并将返回的指针赋值给pptr变量；然后将ptr的地址赋值给pptr指向的地址，从而在分配的内存中创建了一个指针变量。

pptr指向一块能够存放n个int*类型的空间，此处为1，然后将ptr指向的地址作为pptr指向的地址的值，即pptr指向的空间里面存放的是ptr这个指针变量。

**<mark>62.接口怎么设计</mark>**

https://www.cnblogs.com/jerry19880126/archive/2013/06/01/3111845.html

effective c++ 18

**<mark>63.为什么TCP握手的三次而不是俩次</mark>**

[4.1 TCP 三次握手与四次挥手面试题 | 小林coding](https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1)

**<mark>64.线程池 核心参数 你的项目什么时候用了 怎么用的</mark>**

https://huixxi.github.io/2020/06/02/%E5%B0%8F%E7%99%BD%E8%A7%86%E8%A7%92%EF%BC%9A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E7%A4%BE%E9%95%BF%E7%9A%84TinyWebServer/#more

**<mark>65.平时都怎么提升编程水平</mark>**

https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247507074&idx=1&sn=65eb03e1f12f69366d9e6031f50beb8b&chksm=f9a1efd3ced666c59eb3b634f3e8f46c336db747f010b4e571cf7bc0e856a83559c2b7d29654&mpshare=1&scene=24&srcid=03318XORiB4EUYwQIHuHvPo7&sharer_sharetime=1680252346934&sharer_shareid=e06798d9c76a627f13b3b34142f6a646#rd

**<mark>66.手撕string</mark>**

[【C++】手把手教你写出你自己的String类_编写string类_Ornamrr的博客-CSDN博客](https://blog.csdn.net/qq_53268869/article/details/121528154?spm=1001.2014.3001.5501)

[C++ string类的实现_c++ string实现_。菀枯。的博客-CSDN博客](https://blog.csdn.net/m0_60447315/article/details/126448202)

<mark>**67.知道哪些排序算法？**</mark>

冒泡，选择，插入，希尔，归并，快排，桶

**<mark>68.有什么比较有收获或者说让你眼前一亮的知识吗（这里估计想考察对技术的热情）？</mark>**

**<mark>69.虚拟地址空间</mark>**

[4.6 深入理解 Linux 虚拟内存管理 | 小林coding](https://www.xiaolincoding.com/os/3_memory/linux_mem.html#_4-6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86)

从程序局部性原理的描述中我们可以得出这样一个结论：进程在运行之后，不会一下子就要访问全部的内存，相反进程对于内存的访问会表现出明显的倾向性，更加倾向于访问最近访问过的数据以及热点数据附近的数据。

根据这个结论我们就清楚了，无论一个进程实际可以占用的内存资源有多大，根据程序局部性原理，在某一段时间内，进程真正需要的物理内存其实是很少的一部分，我们只需要为每个进程分配很少的物理内存就可以保证进程的正常运行。

而虚拟内存的引入正是要解决上述的问题，虚拟内存引入之后，进程的视角就会变得非常开阔，每个进程都拥有自己独立的虚拟地址空间，进程与进程之间的虚拟内存地址空间是相互隔离，互不干扰的。

每个进程都认为自己独占所有内存空间，所有内存资源都属于它自己，但其实任何一个虚拟内存里所存储的数据，本质上还是保存在真实的物理内存里的。只不过内核帮我们做了虚拟内存到物理内存的这一层映射，将不同进程的虚拟地址和不同内存的物理地址映射起来。

当 CPU 访问进程的虚拟地址时，经过地址翻译硬件将虚拟地址转换成不同的物理地址，这样不同的进程运行的时候，虽然操作的是同一虚拟地址，但其实背后写入的是不同的物理地址，这样就不会冲突了

这样一来我们就可以将多进程之间协同的相关复杂细节统统交给内核中的内存管理模块来处理，极大地降低了编程难度。这一切都是因为虚拟内存能够提供内存地址空间的隔离，极大地扩展了可用空间。

**<mark>70.malloc底层  </mark>**
[4.2 malloc 是如何分配内存的？ | 小林coding](https://www.xiaolincoding.com/os/3_memory/malloc.html)

**<mark>71.键入网址过程  </mark>**

[2.2 键入网址到网页显示，期间发生了什么？ | 小林coding](https://www.xiaolincoding.com/network/1_base/what_happen_url.html)

**<mark>72.伙伴系统</mark>**

[3.2.4 Buddy System(伙伴系统) - Linux核心概念详解](https://s3.shizhz.me/linux-mm/3.2-wu-li-nei-cun/3.2.4-buddy-system-huo-ban-xi-tong)

伙伴算法作为一种行之有效的内存碎片解决办法，和slab一起用来解决内存浪费问题。这套内存管理方法也被很多操作系统所采用，将内存分成若干块，然后尽可能以最适合的方式满足程序内存需求就是伙伴算法的核心。

**<mark>74.C++的内存结构</mark>**

E:/工作/my/c++%20书/C%20八股文/C++八股文/暗黑风格-C++八股文-小贺-v1.0.pdf

全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变ᰁ
和静态变。已经初始化的在.data区域，未初始化的在.bss区域

**<mark>75.什么情况下使用堆区什么情况使用栈区</mark>**

（1）与堆相比，栈不会导致内存碎片，分配效率高。  
所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址， EBP和局部变量都采用栈的方式存放。如果少量数据需要频繁的操作，那么在程序中动态申请少量栈内存（例如使用alloca函数），会获得很好的性能提升。  
（2）堆可以申请的内存大很多。  
与堆相比，栈的使用不是那么灵活，如果分配大量的内存空间，推荐使用堆内存。

**<mark>76.数组和链表的区别</mark>**

https://zhuanlan.zhihu.com/p/52440208

**<mark>77.i = i + 1大概执行多久</mark>**

[i++ 和 ++i 以及 i= i + 1 的运行效率_i = i + 1大概执行多久_wp1995的博客-CSDN博客](https://blog.csdn.net/wp1995/article/details/53120321)

**<mark>78.进程间的通信方式有哪些</mark>**

- 管道：
  
  - 无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。
  
  - 有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。

- 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。

- 消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

- 套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。

- 信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。

- 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问

**<mark>79.了解中断吗</mark>**

[2.6 什么是软中断？ | 小林coding](https://www.xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%B8%AD%E6%96%AD)

[操作系统21-40 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-02-os.html#%E4%B8%AD%E6%96%AD)

**<mark>80.键盘上敲一个字母是什么中断</mark>**

硬中断

**<mark>81.查找一个字符串是否在文件中</mark>**

[在 Linux 上查找文件中字符串的 5 种方法](https://baijiahao.baidu.com/s?id=1731002702404992922&wfr=spider&for=pc)

(1)grep命令： grep string file_name

(2) sed命令：nl filename | sed -n '/string/p'

(3) awk命令：awk '/string/ {print NR":", $0}' filename

(4) less filename **键入**/后跟我们要搜索的字符串，然后按“Enter”。

(5) vi 同(4)

**<mark>82.查找本机一个端口号的状态</mark>**

查看在使用的端口状态：[linux 查看端口状态_bp粉的博客-CSDN博客](https://blog.csdn.net/m0_67392182/article/details/124290054)

netstat -anp | grep 端口号：查看当前端口状态

**<mark>83.几十个G的文件中查找一个字符串是否存在</mark>**

[linux大文件中查找指定字符串--dd+grep_大文件查找字符串_L_学无止境的博客-CSDN博客](https://blog.csdn.net/u011489186/article/details/105790272)

**<mark>84.如何判断远程服务的端口有没有开启</mark>**

方式一：可以先查看地址是否能ping通

ping www.baidu.com

[查看端口](https://so.csdn.net/so/search?q=%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3&spm=1001.2101.3001.7020)是否开放

telnet www.baidu.com 3306

如果命令行窗口不显示任何信息说明端口处于开启状态。

如果端口处于关闭状态，命令行窗口会显示连接失败

方式二：通过tcp的select函数  
原理：设置非阻塞connect，connect的返回值为-1，不能最为判断条件  
通过select函数调用，通过检测远程服务器能否被写 判断端口是否开放和关闭。

**<mark>85.平时在Linux上都用什么命令</mark>**

[Linux面试必备20个常用命令_linux常用命令_袁袁袁袁满的博客-CSDN博客](https://blog.csdn.net/yuan2019035055/article/details/120584242)

**<mark>86.介绍一下OSI七层协议，各层协议都有哪些</mark>**

[2.3 Linux 系统是如何收发网络包的？ | 小林coding](https://www.xiaolincoding.com/network/1_base/how_os_deal_network_package.html#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B)

**<mark>87.百度搜索www.baidu.com到页面出现百度，这中间发生了什么</mark>**

同51.

**<mark>88.baidu.com默认用什么端口</mark>**

80端口是为HTTP（HyperText Transport Protocol)即超文本传输协议开放的，此为上网冲浪使用次数最多的协议，主要用于WWW（World Wide Web）即万维网传输信息的协议。  
众所周知的端口号，范围从0到1023，这些端口号一般固定分配给一些服务。比如21端口分配给FTP服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务，135端口分配给RPC（远程过程调用）服务等等。

80是http协议的默认端口，是在输入网站的时候其实浏览器（非IE）已经帮你输入协议了，所以你输入[http://baidu.com](http://baidu.com/)，其实是访问[http://baidu.com](http://baidu.com/):80。而8080，一般用与webcahe，完全不一样的两个，比如linux服务器里apache默认跑80端口，而apache-tomcat默认跑8080端口，其实端口没有实际意义只是一个接口，主要是看服务的监听端口。  
例如你访问网站，[http://www.baidu.com](http://www.baidu.com/) 默认就是访问80端口

**<mark>89.三次握手</mark>**

[4.1 TCP 三次握手与四次挥手面试题 | 小林coding](https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1)

**<mark>90.两次握手可以吗</mark>**

[4.1 TCP 三次握手与四次挥手面试题 | 小林coding](https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1)

**<mark>91.如果网络情况非常好百分百不会发生拥塞，不会重传SYN，不会有历史连接的问题，可以两次握手吗？</mark>**

不可以，无法同步双方初始序列号。

TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：

- 接收方可以去除重复的数据；
- 接收方可以根据数据包的序列号按序接收；
- 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；

可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 `SYN` 报文的时候，需要服务端回一个 `ACK` 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，**这样一来一回，才能确保双方的初始序列号能被可靠的同步。**

四次握手其实也能够可靠的同步双方的初始化序号，但由于**第二步和第三步可以优化成一步**，所以就成了「三次握手」。

而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。

**<mark>92.什么时候用tcp什么时候用udp</mark>**

[4.1 TCP 三次握手与四次挥手面试题 | 小林coding](https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#udp-%E5%92%8C-tcp-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2-%E5%88%86%E5%88%AB%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF)

**<mark>93.此时此刻的视频面试用的udp还是tcp</mark>**

由于这次是视频面试，我通常会问你觉得牛客网的视频面试是用的TCP还是UDP呢?在我揭晓答案之前大家也可以想想使用的是哪个网络协议，在面试的过程中所有的同学都回答了应该是使用的是UDP。我问为什么使用UDP?基本都会回答道UDP是一个无连接的协议，不用保证可靠性，传输速度快。我又问道如果UDP不保证可靠性，咱们在视频面试的时候我问你问题，如果你回答问题的视频流丢包了，那么你的答案我就听不见了，那视频面试的体验将会非常低。不少同学在这个时候就会改答案说那应该使用的是TCP吧，我这是又会问道TCP由于需要保证可靠性，但是在公网的复杂环境下，想必应该经常会出现缓冲或者卡顿的现象吧，很多同学这个时候就会哑口无言了。

其实这个问题的答案不难想出，我们可以将TCP和UDP的特性互相结合起来，让这个协议既可以保证可靠性，又可以保证实时性，这也就是我们所说的RUDP((Reliable UDP)，常见的RUDP协议有QUIC,WebRTC,Aeron等等，我这里主要介绍谷歌提出的**QUIC**，带大家领略一下RUDP的精彩，看看他们是如何既能做到可靠又能保证效率。

[4.17 如何基于 UDP 协议实现可靠传输？ | 小林coding](https://xiaolincoding.com/network/3_tcp/quic.html)

**<mark>94.udp丢包会有什么现象？</mark>**

UDP丢包会导致数据传输的不完整和不准确。具体现象有：

1. 传输的数据无法到达接收端，导致接收端获取不到完整的数据包。

2. 接收端可能会发现数据包丢失，从而无法正确处理数据。

3. 传输的数据包可能出现乱序，导致接收端无法正确重构数据。

4. 传输的数据包可能被重复发送，导致接收端接收到重复的数据。

5. 传输的数据包可能出现错误，导致接收端无法正确解码数据。
   
   UDP（用户数据报协议）是一种无连接协议，不保证数据包的传送或可靠性。由于网络拥塞、硬件故障或软件错误等多种原因，可能会发生 UDP 中的数据包丢失。当 UDP 数据包丢失时，它不会像在 TCP（传输控制协议）中那样自动重传，因为 UDP 没有检测丢失数据包的机制。发送方不会知道数据包丢失，接收方也不会请求重传。丢失的数据包将被简单地忽略，下一个数据包将被处理。因此，在不能接受数据丢失的情况下，例如在视频会议或在线游戏中，可以使用其他协议或技术（例如纠错、重传或流量控制）来降低数据包丢失的可能性和影响

**<mark>95.http和https的区别</mark>**

1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。

- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。

- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

**<mark>96.证书是绿色的是什么意思？</mark>**

各大主流浏览器的重视，对没有安装SSL证书的网站提示“不安全”，安装了SSL证书的网站浏览器会显示绿色安全标志，表示连接安全

**<mark>97.自己随便编一个证书可以吗？需要去什么地方注册</mark>**

不可以。需要去CA注册

在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

**<mark>98.平常查什么网站？代码、文献、debug习惯</mark>**

https://www.zhihu.com/question/430575159

https://mp.weixin.qq.com/s/-0Hdtl-OucErgK2qjT5Rvg

[写代码需要养成的好习惯_写代码的好习惯_你若不离不弃，我必生死相依的博客-CSDN博客](https://blog.csdn.net/qq_42055933/article/details/127962450)

**<mark>99.proactor和reactor模式</mark>**

[9.3 高性能网络模式：Reactor 和 Proactor | 小林coding](https://www.xiaolincoding.com/os/8_network_system/reactor.html)

**<mark>100.从数据流的角度描述一下proactor模式</mark>**

- **Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件**。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。
- **Proactor 是异步网络模式， 感知的是已完成的读写事件**。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。

**<mark>101.五种IO模型</mark>**

[大白话详解5种网络IO模型](https://baijiahao.baidu.com/s?id=1690471158702755453&wfr=spider&for=pc)

https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274278&idx=4&sn=caa323faf0c51d882453c0e0c6a62282&chksm=83ffbefeb48837e841a6dbff292217475d9075e91cbe14042ad6e55b87437dcd01e6d9219e7d&scene=178&cur_album_id=1339230165934882817#rd

**<mark>100.epoll是同步还是异步的？这个争议很大</mark>**

1.从IO层面来看,epoll绝对是同步的；

2.从消息处理层面来看，epoll是异步的.

**<mark>101.为什么不用异步</mark>**

Linux的异步I/O并不成熟

如果CPU的核心数较多或线程的调度算法优秀的话，即使单核心性能一般，也有可能与异步操作的模式匹敌

**<mark>102.如何用同步IO模拟proactor模式</mark>**

[两种高效的事件处理模式——Reactor和Proactor_同步i/o模拟proactor模式_给我来一杯冰可乐的博客-CSDN博客](https://blog.csdn.net/yang_yi520/article/details/125988656)

**<mark>103.一些场景题，都有很好的引导。高并发情况下的性能提升方法</mark>**

1）、减小锁范围
2）、避免死锁
3）、使用读写锁
4）、使用条件变量
5）、使用原子操作
6）、使用线程池
7）、精心设计你的数据结构
8）、使用内存池
9）、减少内存拷贝
10）、对你的业务流程进行优化
11）、使用内存数据库
12）、使用引用和指针代替值传参
13）、减少对象的构造和析构次数
14）、选择优秀的库
15）、tcp优化，拥塞算法，NODELAY等
16）、使用右值引用
17）、优化你的领域模型

[(153条消息) C++并发编程性能优化_aflyeaglenku的博客-CSDN博客](https://blog.csdn.net/aflyeaglenku/article/details/78637309)

**<mark>104.inux如何切换目录、查看端口绑定情况、查看cpu利用率命令</mark>**

cd

netstat -tunlp | grep 8089，其中 8089 为被占用的端口号

vmstat -n 1   一秒刷新一次

**<mark>105.什么是qps和tps，如何计算</mark>**

**QPS**即每秒查询率。指一台服务器每秒能够响应的查询次数，用于衡量特定的查询服务器在规定时间内所处理流量多少，主要针对专门用于查询的服务器的性能指标。因特网上，经常用每秒查询率来衡量域名系统服务器的机器的性能，即为QPS。

QPS =1000ms/单个请求耗时*服务器核心数（线程数）

**TPS**是每秒事务数。一个事务是指客户端向服务器发送请求然后服务器做出反应的过程，具体的事务定义，可以是一个接口、多个接口、一个业务流程等等。以单接口定义为事务举例，每个事务包括了如下3个过程：

（1）向服务器发请求
（2）服务器自己的内部处理（包含应用服务器、数据库服务器等）
（3）服务器返回结果给客户端
如果每秒能够完成 N 次以上3个过程，TPS 就是 N。

TPS = 事务的数量 / 执行总时间。

**<mark>106.线程池和任务队列有没有做分离</mark>**

有。线程和任务分离,提升线程重用性(线程池分为线程集合和任务队列两部分)

线程池通过run方法从线程队列提取任务,到一个线程中去执行; 有任务就提取执行,无任务则阻塞线程休眠.

**<mark>107.线程池中怎么利用的信号量机制</mark>**

[操作系统01-20 | 阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-os.html#_3-%E4%BF%A1%E5%8F%B7%E9%87%8F)

**<mark>108.CPU利用率拉满的时候在线程池中增加线程是否能提高qps</mark>**

[深入浅出QPS、RT和最佳线程数 - 简书](https://www.jianshu.com/p/8532ac88ce72)

[(153条消息) Amdahl定律和Gustafson定律_secular_的博客-CSDN博客](https://blog.csdn.net/secular_/article/details/109124342)

应该反而会导致CPU利用率降低。

我们不断的增加CoreSize或者说线程数的时候。我们的请求变多了，随之而来的就是大量的上下文切换、大量的GC、大量的锁征用，这些串行化的因素会大大增加F值，也会大大的增加CPU Time。假设我们的串行部分不变的话，增大核数，CPU不能得到充分的利用，利用率也会降低。所以，对于阿姆达尔定律而言，串行化的比率才是决定着是否能成倍增长效率的关键。也就是说最佳线程数也好，最大QPS也好，增加内核数量不一定能是系统指标有成倍的增长。更关键的是能改变自己的架构，减小串行的比率，让CPU更充分的利用，达到资源的最大利用率。

**<mark>109.引导我如何根据CPU利用率动态设计，优化这个线程池</mark>**

1、如果线程执行时，cpu已经高于60%,那么需要把线程池大小调小；

2、如果线程执行时，内存占比较满，那么需要把线程池的队列调小；

为了根据CPU利用率动态地设计和优化线程池，您可以考虑以下几点：

1. 动态调整线程池的大小。根据CPU利用率的情况，您可以动态地增加或减少线程池的线程数。当CPU利用率较高时，您可以减少线程数以节省系统资源；当CPU利用率较低时，您可以增加线程数以提高并发能力

2. 优化线程池的任务调度。为了更好地利用CPU资源，您可以考虑使用不同的任务调度算法来优化线程池的性能。比如，您可以实现一个基于优先级的任务调度算法，让线程池先执行优先级高的任务，以提高应用程序的响应速度。

3. 使用线程池的阻塞队列。阻塞队列可以帮助您更好地管理线程池中的任务。您可以选择不同类型的队列实现，比如有界队列或无界队列，以满足不同的应用场景需求。

4. 使用线程池的回调函数。通过回调函数，您可以更好地控制线程池中任务的执行过程，例如在任务执行前、执行中或执行后进行一些操作。这可以帮助您更好地监控和管理线程池的执行状态，以优化其性能。

总之，只要你理解了线程池的原理和实现，就可以通过上述方法根据CPU利用率动态设计和优化线程池，从而提高程序的性能和响应速度。

**<mark>110.http解析主从状态机</mark>**

https://zhuanlan.zhihu.com/p/560878390

**<mark>111.http的5类状态码</mark>**

同（3）

**<mark>112.是否使用过lib库，动态链接库静态链接库特点、区别</mark>**

静态链接库：

（1）每一个程序在使用静态库时，都会将静态库文件拷贝一份添加到自身，当有多个源文件时，就会造成大量的内存浪费。

（2）每当库函数代码修改了，需要重新编译链接形成可执行程序。

（3）因为在可执行程序中已经具备了所有执行程序所需要的东西，在执行的时候运行速度快。

动态链接库：

（1）当动态库文件在被使用时，会对所有想使用该动态库的源程序添加一个标记，在程序执行时再链接动态库文件使用

（3）库函数代码修改后，不需要重新编译链接

（3）把链接推迟到了运行时，运行速度慢

**<mark>113.进程线程区别、通信方式</mark>**

**<mark>114.static加在全局变量上</mark>**

**<mark>115.加在局部变量上</mark>**

**<mark>116.加在类成员函数上如何使用类中的static成员函数</mark>**

**<mark>117.static数据成员如何修改</mark>**

**<mark>118.const加在不同位置的效果，和static问法差不多</mark>**

**<mark>119.全局变量的默认关键字面向对象三大特性</mark>**

**<mark>120.虚函数表在什么时候创建的、存在什么位置</mark>**

**<mark>121.虚函数存在什么位置</mark>**

**<mark>122.虚函数指针在什么时候创建</mark>**

**<mark>123.虚函数为什么能实现多态</mark>**

**<mark>124.函数调用的过程中堆栈的变化情况</mark>**

**<mark>什么是内存泄漏、如何防止</mark>**

**<mark>既然提到智能指针，说几个常见的，哪个比较熟</mark>**

**<mark>你提到RAII，什么是RAII、智能指针为什么能防止内存泄漏</mark>**

**<mark>看过智能指针的源码吗？讲一下shared_ptr的内部结构</mark>**

**<mark>如果一个传给shared_ptr一个引用，那么引用计数会不会+1</mark>**

**<mark>宏定义，有无类型检查，在什么阶段生效</mark>**

**7. 讲一下 ARP 协议的原理和作用？在哪里会用到 ARP 协议？如果获取不到 MAC 地址会发生什么？  
8. UDP 和 TCP 的区别？分别在哪些场景使用？  
9. 对 Socket 的了解？  
10. 是否了解 Linux 常用命令？  
11. 一个 C++ 程序从编写到执行有哪些阶段？  
12. 预处理过程中的宏定义？宏定义与 const 的区别？  
13. typedef 的作用？  
14. 在 C++中最常用的数据结构？vector？它的缺点？ sort 排序的底层实现？  
15. 编码过程中的问题？（野指针问题）  
16. 如果使用了已经被释放的内存是否会出现错误？可能会出现什么错误？**

**2、 Reactor 模型（为什么用Reactor，Reactor解决了什么实际问题，假设线程池有100个线程，但有1000个用户同时使用，Reactor的具体表现，前端用户的体验是什么样的）和 Proactor模型  
3、IO多路复用的流程和原理  
4、epoll、poll、select特点和区别  
5、有没有考虑程序崩溃情景，项目程序崩溃了怎么办  
6、项目具体应用场景，为什么做这个项目  
7、为什么裸写socket编程而不是使用一些成熟的协议  
8、项目中遇到的印象深刻的问题  
9、TCP如何保证可靠传输  
10、使用TCP编程时，如果服务端程序崩溃了，那么客户端会出现什么情况（分两种情况，服务器关机挂或者服务器上进程挂）  
11、服务器关机时，一定要等到客户端触发TCP的keepalive后客户端才会关闭吗，有什么优化方法吗  
12、线程池的参数  
13、线程和进程的区别（除了常规八股文以外，回答过程中牵扯到了Linux内核源码，给自己挖了坑）  
14、你看过Linux内核源码吗？（因为怕被问源码所以赶紧回答看过一些源码解析）  
15、线程之间共享全局变量如何协调  
16、为什么使用条件变量时总会使用互斥锁  
17、自己有没有碰到过C++的内存泄漏  
18、对于大一点的项目如何快速找出C++内存泄漏的代码  
19、C++中的虚函数  
20、构造函数能不能是虚函数  
21、能不能在构造函数中调用虚函数，会不会编译报错，能不能实现多态  
22、析构函数能不能是虚函数，为什么析构函数要是虚函数  
23、C++和python有什么区别  
24、手撕代码：链表重排序，将1 2 3 4 5重排成1 5 2 4 3  
25、调用new之后底层会做什么  
26、操作系统如何分配内存，从哪里分配内存  
27、归还内存时操作系统会做什么  
28、内存碎片怎么处理**

**1、C++有什么情况会导致宕机？  
2、数组越界为什么会导致宕机？**

**6、迷宫，寻路算法（没看过之前。。。）；然后迷宫有环怎么办？  
7、客户端输入名字的前部分，如有玩家ABC，当客户端输入A时，会有下拉框提示ABC，问数据结构和算法设计（不会啊。。。）  
8、文件读写流程（问磁盘到内存的那些步骤）**

**七层，五层，四层网络结构。  
内存分配方式，如何让类中数据只保存在栈（堆）中。  
内联函数的优点，特性，与宏对比。  
线程间通信方式（就是线程，大意了）。  
粘包的解决方法 。  
TCP，UDP分别在微信的哪个功能上使用比较多，依据。  
TIME_WAIT的作用（两个）。  
拥塞控制，不过没问，说你如果只背过定义就跳过。  
手撕代码，二叉树，根据前序中序数组，构造二叉树。**

****1、除了C++还学过其他语言吗，相比于其他语言，你觉得C++的特点有什么  ****

****3、学校里面你觉得你哪门课学的最好，介绍一下你的学习成果  
4、项目里面有什么参数（例如最大的用户数，文件传输速度等）  
5、项目规模（项目的代码量）  
6、项目中如何组织代码结构，用了什么版本管理工具  
7、C++的虚函数有什么优势和劣势  
8、虚函数可以inline吗  ****
**9、虚函数对性能上除了虚函数表查询的开销以外还有什么缺陷？（面试官提示：从现代编译器角度看。提示之后还是想不到，面试官回答要考虑，是否在一个CPUcache里面，有了虚函数以后，编译器不会做一些很强大的优化）  
10、手撕代码：写一个string类  
11、手撕代码：力扣上hard题目改版，改的更难（力扣239改编）**

****4.在linux下查看进程所耗资源命令  
5.查看网络连接数有多少条命令  
6.netstat 能查看什么连接协议  
7.tcp/udp的区别  ****
**8.tcp/ip握手和挥手的区别  
9.挥手的状态timewait状态和closewait状态发生在什么地方什么时候  
10.timewait数量很多是什么原因造成的（面试官说面过很多人，我是第一个能回答上来的，幸亏面前看了看）  
11.C++和java哪个用的多  **
12.C++数据结构常用哪些  
13.数组和链表的区别  
14.其他的还用过哪些（我回答的Map）  
15.讲讲hashmap底层的结构  
16.堆和栈的区别  
17.http协议消息报文  
18.POST和GET的区别  
19.http是无状态的，开发web的时候怎么知道当前的用户态信息（面试官提示了一下，用cookie，我简单说了一下cookie，他说你这不回答挺好吗）  ****

**20.cookie怎么找到服务器端的信息（session，我当时忘了名字了）  
21.http请求怎么知道成功还是失败？状态码（这个我没太详细记，面试官说很关键，得记记）  
22.epoll和poll和select区别  
23.LT和ET的区别  
24.线程池怎么保证线程安全  
25.互斥锁可以重用吗（他口音太重，开始没听出来）**

1.线程会有自己独立的栈区吗？会有独立的堆区吗？  
1.你了解 Linux 虚拟内存空间吗？  
2.虚拟内存有什么好处？  
3.两个进程 malloc 可能会返回一个值吗？会映射到一个物理地址吗？  
4.影响 C++ class 类的大小的因素有哪些？  
5.内存对齐会有影响吗？  
6.虚函数是怎么实现的？（具体咋问的不太记得了，反正是回答虚函数表底层）  
7.析构函数为什么有时候要是虚函数？  
8.用过智能指针吗？  
9.死锁产生的条件是什么？Cpp 中如何避免死锁？  
10.动态库和静态库有什么区别？  
11.map 和 unordered_map 有啥区别？  
12哈希表怎么处理碰撞问题？最差能退化到什么复杂度？  
13TCP 如何保证可靠？  
14 接 7  一个类空指针可以调用虚函数吗？可以调用普通函数吗？  

代码题 手写生产者消费者模型，我以前没看到过这种设计模式的内容，Cpp 相关库也不会。。。还以为是要自己写 mutex sem 的操作，最后面试官还问我这是原子操作吗，为什么不用 Cpp 的 mutex，我说不会。。。。。

- 存字符串用`unordered_map`还是用`map`好？为什么？要怎么优化？

- 有一个请求队列,有读者线程和写者线程 在同时操作这个共享的请求队列,属于什么样的读写模型 ？

- 一写多读模型的情况下怎么解决读写冲突的问题？加锁是一种方案,但是会影响性能,有没有更好的办法？

- select和epoll有什么区别？

- epoll中可以无限承载socket的连接吗？创建socket时的返回值是什么？

- fd在系统中有限制吗？可以无限申请吗？

- 一个服务端进程最多可以和多少个客户端进行连接？和fd的数量有关吗？

- 假设这样一个场景，客户端在和服务端进行TCP的三次握手的过程中，突然间客户端宕机了，那么这个socket怎么处理？可以删除吗？是怎么删除的？

- 在服务端调用`accept()`之后,socket就是一直可读的吗？就是调用read()函数就一直可以读吗？会阻塞吗？

- 如果服务端read()函数发生了阻塞,对方客户端异常关闭了,一直没有发数据过来,服务端会一直阻塞吗？会导致服务端卡死吗？

- 在第七题中提到的这个情况，epoll可以解决这个问题吗？如果要识别这个问题，怎么识别？

- linux进程创建线程的流程是怎么样的？

- 线程共享进程的资源在linux中是怎么实现的？

- 线程有自己私有的栈，那么这个栈的内存是被分配到哪里的？是放在进程所属的内存里面，还是说放在独立于进程外部的内存中？

- 什么是协程？协程有什么用？

- 场景题：一致性哈希相关

### 对new和malloc的理解

new和malloc都是动态内存分配函数。其中，new是C++中的操作符，malloc是C语言中的函数。new会调用对象的构造函数，而malloc不会。使用new可以简化代码，并且更加类型安全。

**补充：**

new和malloc区别：

- **分配内存的位置**：malloc是从堆上动态分配内存，new是从自由存储区为对象动态分配内存。自由存储区的位置取决于operator new的实现。自由存储区不仅可以为堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

- **返回类型安全性**：malloc内存分配成功后返回void*，然后再强制类型转换为需要的类型；new操作符分配内存成功后返回与对象类型相匹配的指针类型；因此new是符合类型安全的操作符。

- **内存分配失败返回值**：malloc内存分配失败后返回NULL。new分配内存失败则会抛异常（bac_alloc）。

- **分配内存的大小的计算**：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

- **是否可以被重载**：opeartor new /operator delete可以被重载。而malloc/free则不能重载。

### new是在内存上哪一块去分配的内存

堆

**补充：**

new所申请的内存区域在C++中称为自由存储区。很多编译器的new/delete都是以malloc/free为基础来实现的，所以通常都是借由堆实现来实现自由存储，这时候就可以说new所申请的内存区域在堆上。

### 如果new内存失败了会是怎么样？

会抛出std::bad_alloc异常。

**补充：**

如果加上std::nothrow关键字，A* p = new (std::nothrow) A;，new 就不会抛出异常而是会返回空指针。

### 析构函数为什么通常是会做成一个虚函数呢

如果一个类有虚函数，就应该为其定义一个虚析构函数。这是因为在使用delete操作符释放一个指向派生类对象的基类指针时，如果基类的析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数，这样就会导致内存泄漏和未定义行为的问题。通过将析构函数定义为虚函数，可以确保在释放派生类对象时，先调用派生类的析构函数，再调用基类的析构函数，从而避免内存泄漏和未定义行为的问题。

### 线程和进程有什么区别

进程是程序在操作系统中的一次执行过程，它拥有独立的地址空间和系统资源。线程是进程中的一个执行单元，同一进程内的多个线程共享相同的地址空间和系统资源。

**补充：**

- 进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序；线程是程序执行的基本单位，每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。

- 每个进程有自己的独立地址空间，不与其他进程分享；一个进程里可以有多个线程，彼此共享同一个地址空间。堆内存、文件、套接字等资源都归进程管理，同一个进程里的多个线程可以共享使用。每个进程占用的内存和其他资源，会在进程退出或被杀死时返回给操作系统。

- 并发应用开发可以用多进程或多线程的方式。多线程由于可以共享资源，效率较高；反之，多进程（默认）不共享地址空间和资源，开发较为麻烦，在需要共享数据时效率也较低。但多进程安全性较好，在某一个进程出问题时，其他进程一般不受影响；而在多线程的情况下，一个线程执行了非法操作会导致整个进程退出。

### 右值引用有什么作用

没用过

**补充：**

- 右值引用是C++11引入的特性，它是指对右值进行引用的一种方式。右值引用的作用主要有两个：

- 可以通过右值引用来实现移动语义。移动语义可以在不进行深拷贝的情况下，将对象的资源所有权从一个对象转移到另一个对象，从而提高代码的效率。

- 右值引用还可以用于完美转发。在函数模板中，通过使用右值引用类型的形参来接收参数，可以实现完美转发，即保持原参数的值类别（左值还是右值），将参数传递给另一个函数。

### 智能指针

智能指针是C++中的一种特殊指针，它是一个对象，用来管理另一个指针所指向的对象的生命周期。智能指针可以自动地分配和释放内存，避免手动管理内存的麻烦和出错风险。

C++标准库提供了三种智能指针：

- shared_ptr：多个智能指针可以共享同一个对象，当最后一个指针被销毁时，它会释放对象的内存。

- unique_ptr：独占式智能指针，不能共享同一个对象，当智能指针被销毁时，它会释放对象的内存。

- weak_ptr：弱引用智能指针，不会增加对象的引用计数，用于避免shared_ptr循环引用时的内存泄漏问题。

### 在哪些场景下会应用智能指针

我自己是在在动态内存管理中，使用智能指针可以避免手动管理内存的麻烦和出错风险。

### 如果遇到内存泄漏这种问题，你一般是怎么去解决

打断点定位然后做处理

后来思考对方应该是想让我回答这种处理措施⬇️

- 在程序中加入必要的错误处理代码，避免程序因为异常情况而导致内存泄漏。

- 使用智能指针等RAII机制，自动管理内存，避免手动管理内存的麻烦和出错风险。

- 使用内存分析工具，检测程序中的内存泄漏，并进行相应的修复。

### class中缺省的函数

没关注

**补充：**

在C++中，如果一个类没有显式地定义「构造函数、析构函数、拷贝构造函数、赋值运算符重载函数」，那么编译器会自动生成这些函数，这些函数被称为缺省函数。

### sort函数内部是什么

sort函数内部使用快速排序算法实现，它的时间复杂度为O(nlogn)，是一种非常高效的排序算法。

### 快排的原理

1. 选择一个基准元素。

2. 将小于等于基准元素的元素移动到数组左边，大于基准元素的元素移动到数组右边，这个过程称为划分。

3. 递归地对划分后的左右两个子序列进行排序。

但是仔细想想还可以继续回答⬇️

在实际实现中，sort函数还有一些优化，例如：

- 当排序的元素个数小于一定阈值时，使用插入排序算法。

- 当出现大量重复元素时，使用三向划分快速排序算法。

### 为什么选快排

默认它的分布是比较随机的那种分布，然后快排在比较随机的分布上，表现的比较好，速度比较快

### 多线程锁是什么

多线程锁是一种用来保护共享资源的机制。在多线程编程中，如果多个线程同时访问同一个共享资源，可能会发生竞态条件（Race Condition），导致程序的行为出现未定义的情况。为了避免这种情况的发生，可以使用多线程锁来保护共享资源。

多线程锁的基本思想是，在访问共享资源之前先获取锁，访问完成之后再释放锁。这样可以保证同一时刻只有一个线程可以访问共享资源，从而避免竞态条件的发生。

常见的多线程锁包括互斥锁、读写锁、条件变量等。其中，互斥锁用于保护共享资源的访问，读写锁用于在读多写少的情况下提高并发性能，条件变量用于线程之间的同步和通信。

### mysql的事务是什么

在数据库中，事务（Transaction）是一组操作单元，这些操作单元要么全部执行成功，要么全部执行失败。事务是保证数据库一致性的重要机制之一，它可以将一系列的操作看作一个整体，从而保证数据库的完整性和正确性。

事务具有四个特性，即ACID：

- 原子性（Atomicity）：事务中的所有操作要么全部执行成功，要么全部执行失败，不会出现部分执行的情况。

- 一致性（Consistency）：事务执行前后数据库的状态是一致的，即数据库中的约束和规则都得到了保持。

- 隔离性（Isolation）：多个事务并发执行时，相互之间不会影响彼此的执行结果。

- 持久性（Durability）：事务执行完成后，对数据库所作的修改将被永久保存到数据库中。

MySQL是一种常见的关系型数据库，支持事务的机制。在MySQL中，事务可以

通过使用事务控制语句（Transaction Control Statements）来进行管理，包括以下三个语句：

- START TRANSACTION：开始一个事务。

- COMMIT：提交一个事务，使之生效。

- ROLLBACK：回滚一个事务，使之失效。

在MySQL中，事务默认是关闭的，需要通过设置autocommit参数为0来启用事务。启用事务后，可以通过执行SQL语句来进行事务操作，

### TCP连接中间会有什么操作

在TCP连接中，客户端和服务器之间会进行以下操作：

- 握手阶段：客户端向服务器发送SYN包（同步包），请求建立连接。服务器收到SYN包后，向客户端发送SYN+ACK包（同步确认包），表示可以建立连接。客户端收到SYN+ACK包后，再向服务器发送ACK包（确认包），表示连接建立成功。

- 数据传输阶段：连接建立成功后，客户端和服务器之间可以进行数据的传输。客户端向服务器发送数据包，服务器接收数据包并进行处理，然后向客户端发送响应包。客户端收到响应包后，可以再次向服务器发送数据包，以此类推。

- 断开连接阶段：当客户端或服务器不再需要连接时，可以发送FIN包（结束包）来请求断开连接。对方收到FIN包后，也发送FIN包进行响应，表示同意断开连接。当两端都收到对方的FIN包后，连接才真正关闭。

需要注意的是，在TCP连接中可能会出现丢包、拥塞等情况，需要进行相应的处理，例如重传丢失的数据包、调整发送窗口大小等。

1.谈论一下你对面向对象的看法

2.c++有几种继承

3.子类已经重写,如何调用父类的函数

4.有向图和无向图是什么,都作用在什么地方

5.了解红黑树吗

6.了解完全二叉树吗

7.linux的常见命令,vim如何删除一行(我都是直接删的,不会

8.讲一下智能指针

了解计算机网络吗，https协议怎么保证安全的，保证的是哪部分安全。

多态的几种类型，虚基类是什么概念？

glibc的内存管理实现

vector增加元素是值拷贝还是指针拷贝？

```
//问最后的输出结果，*(p + 4) - *(p + 0)我第一次说16，最后说4，感觉就是16啊，为啥子？
#include <stdio.h>
int a[] = {1, 3, 5, 7, 9};
int *p[] = {a, a + 1, a + 2, a + 3, a + 4};

int main()
{
    printf("%d %d %d\n", a[4], *(a + 2), *p[1]);                                  // 9 5 3
    printf("%d %d %d\n", **(p + 1) + a[2], *(p + 4) - *(p + 0), *(a + 3) % a[4]); // 8 4 7
    printf("%d %d \n", *(p + 4), *(p + 0)); //4206640 4206624 不懂为啥减完成4了？
    return 0;
}
```

```
#include <iostream>
using namespace std;
class A
{
public:
    A() { cout << "A::A()called.\n"; }
    virtual ~A() { cout << "A:~A()called.\n"; }
};

class B : public A
{
public:
    B(int i)
    {
        cout << "B::B()called.\n";
        buf = new char[i];
    }
    virtual ~B()
    {
        delete[] buf;
        cout << "B:~B()called.\n";
    }

private:
    char *buf;
};

void fun(A *a)
{
    delete a;
}

int main()
{
    A *a = new B(15);
    fun(a);
    return 0;
}
//程序输出：
A::A()called.
B::B()called.
B:~B()called.
A:~A()called.
```

python中列表和元组的区别

介绍pytorch、ros框架（项目中有提到）

```
void newMemory(char *p)
{
    p = (char *)malloc(100);
}

void func(void)
{
    char *str = NULL;
    newMemory(str);
    strcpy(str, "Memory test");//字符串复制函数
    printf(str);
}
```

Q:IIC通信协议中的ACK和NACK表示什么？

Q:SPI有几根线

Q:UART一般有几个信号

A:RX，TX。

Q:TCP的关闭连接过程

A:四次挥手，以及四次挥手的过程

Q:vim里替换一段字符串是怎么做的？

A:没打上来,说了自己经常用的几个vim命令

Q：linux中替换某个文件中的字符串

A：没打上来。。。

Q:linux查找某个字符串

Q:git问题：merge时候出现conflict怎么办？

面向过程？

百度（因为是第一次面试，非常紧脏，所以问了一些基础的问题就秒挂了。）：

1. golang管道怎么用
2. golang的goroutue泄露
3. tcp和udp的区别
4. tcp三次握手四次挥手
5. tcp四次挥手第二次和第三次不能合并吗
6. 手写一个单例模式
7. 设计模式几大原则
8. 手撕单例模式（懒汉模式）
9. 手撕二分查找。

美团（鸡架，无人机团队）：

一面：

1. 多态和继承在什么情况下使用
2. 除了多态和继承还有什么面向对象方法
3. 情景题。手机店。不同品牌的不同型号手机有不同的业务逻辑。怎么设计系统
4. tcp/ip五层模型
5. dns服务器用的是什么协议。
6. ping命令 用的是什么协议。在哪一层。
7. tcp拥塞控制实现。
8. 模板元编程（简历上写了，但答的不好）
9. 为什么要用多线程。多进程可以吗（webserver的）
10. 进程和线程的区别。
11. 为什么要用线程池
12. 讲讲智能指针
13. C++内存分布。什么样的数据在栈区，什么样的在堆区。
14. C++内存管理（RAII啥的）
15. C++从源程序到可执行程序的过程
16. 编译阶段的过程（编译原理，词法分析啥的）。每个过程干啥的
17. 为什么要用epoll
18. 怎么debug，怎么看内存泄漏。
19. 聊天

二面：

1. epoll实现原理
2. reactor和proactor的好处和坏处。为什么要用reactor而不用proactor
3. 能详细讲一下有限状态机怎么解析http报文吗
4. 小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题
5. 如果有两个服务器，一个服务器坏了，另一个服务器怎么判断并接手坏的服务器的用户数据（共用一个堆
6. 堆和栈的区别。什么情况下会往堆里放
7. 一个对象=另一个对象会发生什么（赋值构造函数）
8. 如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）
9. c++11的智能指针有哪些。weak_ptr的使用场景。什么情况下会产生循环引用
10. 多进程fork后不同进程会共享哪些资源
11. 多线程里线程的同步方式有哪些

后面的基本没有记录，只记得手撕和一些面试的时候卡住/不确定的问题。（主要是懒了）

图森未来：

一面（coding面）：leetcode:694. 不同岛屿的数量。还有一题忘了。八股问题主要是cpp相关。

二面：手撕智能指针。八股问题忘了。

三面：

1. select怎么用。底层原理
2. select为什么只能支持1024个。poll和epoll是怎么解决这个问题的。
3. epoll 底层为什么用红黑树不用hash
4. py修饰器

柠檬微趣：

1. size_of是在编译期还是在运行期确定
2. 函数重载的机制。重载是在编译期还是在运行期确定
3. hash表数据很大。rehash的代价很高，怎么办
4. 如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）

杭州默安：主要是面了golang。只记得一些。

1. 数组和切片的区别
2. GPM调度
3. sync库用过哪些。
4. golang的协程。py的协程。
5. mysql的隔离级别和锁。
6. k8s，一些其他的sql了解过吗。
